# kps/aes_cipher.py
"""
Lightweight symmetric cipher used to demonstrate encryption with the
shared key derived from the key predistribution scheme.

Why not use a third-party AES implementation?
---------------------------------------------
The execution environment for this project does not always permit
installing external dependencies (e.g., ``pycryptodome``). To keep the
demo runnable anywhere, we provide a minimal stream cipher built on
standard library primitives:

* A keystream is generated by hashing the secret key + nonce + counter
  with SHA-256.
* Encryption/decryption XOR the keystream with the plaintext/ciphertext.
* An HMAC tag (using the same key) authenticates the ciphertext.

This is **not** a drop-in replacement for production AES-GCM, but it
preserves the intended educational flow without extra packages.
"""

import hmac
import secrets
from hashlib import sha256


class AESCipher:
    """
    Symmetric stream cipher with HMAC authentication.

    A new instance should be created for each derived shared key.
    """

    def __init__(self, key: bytes) -> None:
        if not isinstance(key, (bytes, bytearray)) or len(key) == 0:
            raise ValueError("Key must be non-empty bytes")
        self.key = bytes(key)

    def _keystream(self, nonce: bytes, length: int) -> bytes:
        """Generate a pseudorandom keystream of ``length`` bytes."""
        stream = bytearray()
        counter = 0
        while len(stream) < length:
            counter_bytes = counter.to_bytes(8, "big")
            block = sha256(self.key + nonce + counter_bytes).digest()
            stream.extend(block)
            counter += 1
        return bytes(stream[:length])

    def encrypt(self, plaintext: bytes) -> tuple[bytes, bytes, bytes]:
        """
        Encrypt the given plaintext.

        Returns (nonce, ciphertext, tag).
        """
        nonce = secrets.token_bytes(12)
        keystream = self._keystream(nonce, len(plaintext))
        ciphertext = bytes(p ^ k for p, k in zip(plaintext, keystream))
        tag = hmac.new(self.key, nonce + ciphertext, sha256).digest()
        return nonce, ciphertext, tag

    def decrypt(self, nonce: bytes, ciphertext: bytes, tag: bytes) -> bytes:
        """
        Decrypt and verify the given ciphertext.
        Raises ValueError if tag verification fails.
        """
        expected_tag = hmac.new(self.key, nonce + ciphertext, sha256).digest()
        if not hmac.compare_digest(expected_tag, tag):
            raise ValueError("Authentication tag mismatch")

        keystream = self._keystream(nonce, len(ciphertext))
        return bytes(c ^ k for c, k in zip(ciphertext, keystream))
